#version 450

#include <lluvia/core.glsl>

layout(binding = 0, rgba32f) uniform image2D input_gradient;
layout(binding = 1, r32f) uniform image2D output_image;

layout(push_constant) uniform const_0 {
    float texelWidth;
    float texelHeight;
    float upperThreshold;
    float lowerThreshold;
} params;

void main()
{

	const ivec2 coords  = LL_GLOBAL_COORDS_2D;
    const ivec2 imgSize = imageSize(input_gradient);

    if (coords.x > imgSize.x || coords.y > imgSize.y) {
        return;
    }

    vec3 currentGradientAndDirection = imageLoad(input_gradient, coords).rgb;
    // vec2 gradientDirection = ((currentGradientAndDirection.gb * 2.0) - 1.0) * vec2(params.texelWidth, params.texelHeight);
    vec2 gradientDirection = currentGradientAndDirection.gb * vec2(params.texelWidth, params.texelHeight);

    float firstSampledGradientMagnitude = imageLoad(input_gradient, coords + ivec2(gradientDirection)).r;
    float secondSampledGradientMagnitude = imageLoad(input_gradient, coords - ivec2(gradientDirection)).r;

    float multiplier = step(firstSampledGradientMagnitude, currentGradientAndDirection.r);
    multiplier = multiplier * step(secondSampledGradientMagnitude, currentGradientAndDirection.r);

    float thresholdCompliance = smoothstep(params.lowerThreshold, params.upperThreshold, currentGradientAndDirection.r);
    multiplier = multiplier * thresholdCompliance;

    imageStore(output_image, coords, vec4(multiplier, multiplier, multiplier, 1.0));
}
